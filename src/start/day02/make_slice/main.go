package main

import "fmt"

// make创建切片  可以指定切片的长度 和容量
// 切片的本质就是 数组底层的封装 属于引用类型 本身就是一个框 框住了内存   真正的数据都是保存在底层数组里

func main() {
	//参数1 切片元素类型  参数2 长度 参数3容量 如果没有填写第三个参数 则默认值等于第二个参数
	s1 := make([]int, 5, 10)                                            //如果长度为0  则输出没有值
	fmt.Printf("s1=%v\nlen(s1)=%d\ncap(s1)=%d\n", s1, len(s1), cap(s1)) //[0 0 0 0 0] 5 10

	// 切片之间不能进行比较  只能判断是否为空 并且必须要用 len(s1)== 0 来判断  不能使用 s1 == nil

	// 一个nil值的切片并没有底层数组
	// 一个nil值的切片的长度和容量都是0
	// 一个长度和容量都是0的不一定是nil

	//判断切片是否为空 不能用 ==nil 要用 len(切片) == 0

	// 切片的赋值 和往常的不一样  因为此时操作的是他的底层数组  切片就是一个框 值都是从底层数组拿到的
	s3 := []int{1, 3, 5}
	s4 := s3
	fmt.Println(s3, s4) //[1 3 5] [1 3 5]
	s3[0] = 100
	fmt.Println(s3, s4) //[100 3 5] [100 3 5]
	fmt.Println("-----------------------------------------------------------")

	int1 := 1
	int2 := int1
	int1 = 2
	fmt.Println(int1, int2) //2 1

	fmt.Println("-----------------------------------------------------------")

	// 切片的循环
	// 1.索引遍历
	for i := 0; i < len(s3); i++ {
		fmt.Println(s3[i])
	}
	fmt.Println("----------------------")
	//for range
	for _, v := range s3 {
		fmt.Println(v)
	}
	fmt.Println("----------------------")

}
